def cmp(x):                                # компаратор для сорта gpa
    error = 4.000 - float(x[1])       # находим error(дискреция в сорте), чтобы могли сортировать по гпа, иначе по именам
    return (error, x[0])                  

n = int(input())
gpa_cnt, gpa_occ = {}, {}           # gpa_cnt словарь для сохранении общих гпа, то есть плюсую все гпа одного человека
                                    # gpa_occ словарь для сохранении количества людей, которые встречаются более 1 раза
while n > 0:
    x = input().split()
    gpa_occ[x[0]] = gpa_occ.get(x[0], 0) + 1        # считаю occurence каждого чела, чтобы потом поделить это на общий gpa
    
    if x[0] not in gpa_cnt.keys():
        gpa_cnt[x[0]] = int(x[1])               # если чел впервые встречается в списке, просто приравниваю его gpa на value
    else:                                       # иначе добавляю gpa на тот, который был раньше
        gpa_cnt[x[0]] += int(x[1])        

    n -= 1

gpa = {}        # словарь, в котором будут все средние gpa студентов

for key, value in gpa_cnt.items():      # key это имена студентов, а value общий gpa каждого студента
    gpa[key] = f'{value / gpa_occ[key]:.3f}'  # value / gpa_occ[key] это формула для нахождения среднего gpа
                                              # gpa_occ[key] вызывает количество occurence каждого студента
                                              # то есть по формуле мы делим сумму общего gpa на количество семестров студента (gpa_occ[key])

for key, value in sorted(gpa.items(), key=cmp):  # вывод конечного ответа, внутри сорта прикрепляем наш компаратор(cmp) на функцию key
    print(key + ': ' + value)